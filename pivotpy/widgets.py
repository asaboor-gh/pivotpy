# AUTOGENERATED! DO NOT EDIT! File to edit: Widgets.ipynb (unless otherwise specified).

__all__ = ['css_style', 'dark_colors', 'light_colors', 'simple_colors', 'get_files_gui', 'InputGui', 'generate_summary',
           'KPathApp']

# Cell
import os
import json
from time import sleep

# Widgets Imports
from IPython.display import display, Markdown
import ipywidgets as ipw
from ipywidgets import Layout,Label,Button,Box,HBox,VBox,Dropdown,Text,Checkbox
from ipywidgets.embed import embed_minimal_html, dependency_state

# More exports
import numpy as np
import pandas as pd
import plotly.graph_objects as go

# Inside packages import to work both with package and jupyter notebook.
try:
    from pivotpy import g_utils as gu
    from pivotpy import vr_parser as vp
    from pivotpy import i_plots as ip
    from pivotpy import s_plots as sp
    from pivotpy import sio
except:
    import pivotpy.g_utils as gu
    import pivotpy.vr_parser as vp
    import pivotpy.i_plots as ip
    import pivotpy.s_plots as sp
    import pivotpy.sio as sio

# Cell
def css_style(colors_dict):
    """Return style based on colors_dict available as pp.light_colors, pp.dark_colors etc"""
    return """<style>
    .widget-label-basic {{
        background-color: transparent !important;
        color: {text} !important;
    }}
    .widget-text input {{
        background-color: {input_bg} !important;
        border-radius:20px !important;
        padding: 0px 10px 0px 10px !important;
        border: 1px solid {input_border} !important;
        color: {input_fg} !important;
        }}
    .widget-text input:focus {{
        border: 1px solid {input_hover} !important;
        }}
    .widget-text input:hover {{
        border: 1px solid {input_hover} !important;
        }}
    .widget-dropdown > select {{
        background-color: {dd_select_bg} !important;
        border:none !important;
        border-bottom: 1px solid {input_hover} !important;
        box-shadow: inset 0 -20px 10px -20px {input_hover};
        color: {dd_select_fg} !important;
    }}
    .widget-dropdown > select:hover {{
        background-color: {dd_hover} !important;
    }}
    .widget-dropdown > select > option {{
        color: {dd_opt_fg} !important;
        background-color: {dd_opt_bg} !important;
    }}
    .widget-dropdown > select > option:focus {{
        background-color: {dd_focus_bg} !important;
    }}
    .widget-label {{
        color: {text} !important;
    }}
    .widget-html {{
        color: {text} !important;
    }}
    .widget-box {{
        background-color: {box_bg} !important;
        border-radius:5px !important;
        padding:1px !important;
        border: 1px solid {box_border} !important;
        box-shadow: 1px 1px 1px 1px {box_border} !important;
    }}
    .borderless {{
        border: 1px solid transparent !important;
        box-shadow: none !important;
        border-radius: 4px !important;
        margin:4px !important;
    }}
    .marginless {{
        margin: 0px !important;
        border-radius: 0px !important;
    }}
    .output {{
        color: {text} !important;
        background-color: inherit !important;
    }}
    .widget-tab {{
        background-color: {tab_bg} !important;
        border: none !important;
        box-shadow: 1px 1px 1px 1px {tab_shadow} !important;
        padding: 0px 2px 2px 2px !important;
    }}
    .widget-tab-contents, .widget-tab > .widget-tab-contents {{
        width: 100%;
        box-sizing: border-box;
        margin: 0px !important;
        padding: 0px !important;
        flex-grow: 1;
        overflow: auto;
        border: none !important;
        background-color: {tab_bg} !important;
    }}
    .widget-tab > .p-TabBar .p-TabBar-tab {{
        background-color:{tab_bg} !important;
        border: none !important;
        color: {tab_fg} !important;
        font-weight: bold !important;
        font-size: 16px !important;
        font-family: "Times","serif" !important;
        text-align: center !important;
    }}
    table {{
        color: {table_fg} !important;
        }}
    tr:nth-child(odd) {{
        background-color: {tr_odd_bg} !important;
        }}
    tr:nth-child(even) {{
        background-color: {tr_even_bg} !important;
        }}
    .widget-button,.widget-toggle-button {{
        color: 	{btn_fg} !important;
        min-width: max-content !important;
        background-color: {btn_bg};
        border-radius: 5px !important;
    }}
    tr:hover {{
        background-color: {tr_hover_bg} !important;
        }}
    </style>
    """.format(**colors_dict)

dark_colors = {
 'table_fg': '#ABB2BF',
 'tr_odd_bg': '#282C34',
 'tr_even_bg': '#21252B',
 'tr_hover_bg': '#414855',
 'btn_fg': '#ABB2BF',
 'btn_bg': '#3D4450',
 'tab_bg': '#21252B',
 'tab_fg': '#61AFEF',
 'tab_shadow': '#282C34',
 'box_bg': '#21252B',
 'box_border': '#282C34',
 'text': '#ABB2BF',
 'input_bg': '#282C34',
 'input_fg': '#ABB2BF',
 'input_border': '#282C34',
 'input_hover': '#414855', # For focus and hover on border, also for dd se
 'dd_select_fg': '#ABB2BF',
 'dd_select_bg': 'transparent',
 'dd_hover': '#3D4450',
 'dd_opt_bg': '#282C34',
 'dd_opt_fg': 'whitesmoke',
 'dd_focus_bg': 'green'}

light_colors = {
    'table_fg'    : 'black',
    'tr_odd_bg'   : '#eaf0f0',
    'tr_even_bg'  : 'white',
    'tr_hover_bg' : '#abe4ff',
    'btn_fg'      : 'black',
    'btn_bg'      : '#c3d4d4',
    'tab_bg'      : '#F3F3F3',
    'tab_fg'      : 'black',
    'tab_shadow'  : 'gray',
    'box_bg'      : '#F3F3F3',
    'box_border'  : 'whitesmoke',
    'text'        : 'black',
    'input_bg'    : 'white',
    'input_fg'    : 'gray',
    'input_border': '#e0e8e8',
    'input_hover' : 'skyblue', # For focus and hover on border, also for dd select
    'dd_select_fg': 'skyblue',
    'dd_select_bg': 'transparent',
    'dd_hover'    : 'white',
    'dd_opt_bg'   : '#eaf0f0',
    'dd_opt_fg'   : 'gray',
    'dd_focus_bg' : 'red'
}
simple_colors = {
    'table_fg': 'black',
    'tr_odd_bg': 'whitesmoke',
    'tr_even_bg': 'white',
    'tr_hover_bg': 'lightgray',
    'btn_fg': 'black',
    'btn_bg': 'whitesmoke',
    'tab_bg': 'white',
    'tab_fg': 'black',
    'tab_shadow': 'white',
    'box_bg': 'white',
    'box_border': 'white',
    'text': 'black',
    'input_bg': 'white',
    'input_fg': 'black',
    'input_border': 'lightgray',
    'input_hover': 'gray',
    'dd_select_fg': 'black',
    'dd_select_bg': 'transparent',
    'dd_hover': 'whitesmoke',
    'dd_opt_bg': 'white',
    'dd_opt_fg': 'black',
    'dd_focus_bg': 'white'
}

# Cell
def get_files_gui(auto_fill = 'vasprun.xml',html_style=None,height=320):
    """
    - Creates a GUI interface for files/folders filtering.
    - **Parmeters**
        - auto_fill  : Default is `vasprun.xml`, any file/folder.
        - html_style : None,Output of `css_style`.
        - height     : Height of Grid box.
    - **Returns**
        - Tuple(GUI_gridbox,Files_Dropdown). Access second one by item itself.
    """
    files_w = ipw.Dropdown(continuous_update=False)
    pw = ipw.Text(value=os.getcwd())

    incldue_w = ipw.Text(value=auto_fill)

    excldue_w = ipw.Text()
    d_layout = Layout(width='30%')
    l_layout = Layout(width='19%')
    depth_w = ipw.Dropdown(options=[None,1,2,3,4,5],value=4,layout=d_layout)
    item_w = ipw.Dropdown(options=['Both','Files','Folders'],value='Files',layout=d_layout)
    item_box = ipw.HBox([ipw.Label('Depth: ',layout=l_layout),depth_w,ipw.Label('Type: ',layout=l_layout),item_w])
    item_box.add_class('borderless').add_class('marginless')

    applybtn_w = ipw.Button(description='Apply Filters')
    gci_output = ipw.Output(layout=Layout(height='{}px'.format(height-70)))
    label_head = ipw.HTML("<h3>Your Filtered Files List</h3>")


    def filter_gci(applybtn_w):
        applybtn_w.description = 'Applying...'
        applybtn_w.disabled = True
        if os.path.isdir(pw.value):
            path = pw.value
        else:
            with gci_output:
                print("Given path does not exists.")
                print("Falling back to PWD: {}".format(os.getcwd()))
            path = os.getcwd()
            pw.value = path
        gci = vp.Dict2Data({'children':[],'parent':path})

        if 'Files' in item_w.value:
            file_type = dict(filesOnly=True)
        elif 'Folders' in item_w.value:
            file_type = dict(dirsOnly=True)
        else:
            file_type = {}
        try:
            gci = gu.get_child_items(path=path, **file_type,
                           include= incldue_w.value,
                           exclude= excldue_w.value,
                           depth=depth_w.value)
        except:
            with gci_output:
                print('Something went wrong')
        # Enable before any error occur.
        applybtn_w.disabled = False
        files_w.options = {name: os.path.join(gci.parent,name) for name in gci.children}

        applybtn_w.description = 'Successful!'
        label_head.value = "<h3>From: {}</h3>".format(gci.parent)
        with gci_output:
            display(ipw.HTML("<h4>{} files found.</h4>".format(len(gci.children))))
            display(ipw.HTML("<ol>{}<ol>".format(''.join(['<li>{}</li>'.format(i) for i in gci.children]))))


        applybtn_w.description = 'Apply Filters'
        gci_output.clear_output(wait=True)

    applybtn_w.on_click(filter_gci)
    out_box = ipw.Box([gci_output])
    right_box = ipw.VBox([label_head,out_box])
    out_box.add_class('borderless')
    right_box.add_class('borderless')
    i_layout = Layout(width='99%')
    incldue_w.layout = i_layout
    excldue_w.layout = i_layout
    pw.layout = i_layout
    input_box = ipw.VBox([
        ipw.Label('Path to Project Folder',layout=i_layout),pw,
        ipw.Label('Items to Include (separate by |)',layout=i_layout),incldue_w,
        ipw.Label('Items to Exclude (separate by |)',layout=i_layout),excldue_w,
        item_box,
        applybtn_w],layout=Layout(width='330px'))
    if not html_style:
        html_style = ''
    full_box = ipw.HBox([ipw.HTML(html_style),input_box, right_box],
                        layout=Layout(height='{}px'.format(height)))
    full_box.add_class('borderless')
    full_box.add_class('marginless')
    return full_box, files_w

# Cell
class InputGui:
    def __init__(self,sys_info=None,html_style=None,height=400):
        """
        - Creates a GUI interface for input/selection of orbitals/elms projection.
        - **Parmeters**
            - html_style : None,Output of `css_style`.
            - height     : Height of Grid box, Can set to None for auto-resizing.
            - sys_info   : `export_vasprun().sys_info`. Can change later using `self.update_options` mthod.
        - **Output Parameters**
            - output: Dictionary that contains kwargs for plot functions.
            - html  : A widget which can be used to bserve change in output, used in `VasprunApp`.
        """
        html_style = html_style if html_style else '' # Not self
        self.sys_info = sys_info if sys_info else vp.Dict2Data({'fields':['s'],
                                                'ElemIndex':[0,1],'ElemName':['A']})
        self.output = dict(elements = [[],[],[]],orbs = [[],[],[]],labels = ['','',''])

        layout = Layout(width='30%')
        l_width = Layout(width='20%')
        self.html = ipw.HTML() # For Display in Big App as well. Very important
        self.dds = {
            'elms': Dropdown(layout=layout),
            'orbs': Dropdown(layout=layout),
            'rgb' : Dropdown(options={'Red':0,'Green':1,'Blue':2},value=0,layout=layout)
            }
        self.texts = {
            'orbs' : Text(layout=layout,continuous_update=False),
            'elms' : Text(layout=layout,continuous_update=False),
            'label': Text(layout=layout,continuous_update=False)
            }
        self.update_options(self.sys_info) # In start if given

        self.box = VBox([ipw.HTML(html_style),
                self.html,
                HBox([Label('Color: ',layout=l_width), self.dds['rgb'],
                      Label('Label: ',layout=l_width),self.texts['label']
                    ]).add_class('borderless').add_class('marginless'),
                HBox([Label('Ions: ',layout=l_width),self.dds['elms'],
                      Label('::>>:: ',layout=l_width),self.texts['elms']
                    ]).add_class('borderless').add_class('marginless'),
                HBox([Label('Orbs: ',layout=l_width),self.dds['orbs'],
                      Label('::>>:: ',layout=l_width),self.texts['orbs']
                    ]).add_class('borderless').add_class('marginless')
                ],layout=Layout(height="{}px".format(height))
                ).add_class('marginless')

        #Obsever
        self.dds['rgb'].observe(self.__see_input,'value')
        self.texts['label'].observe(self.__read_pro,'value')
        self.texts['orbs'].observe(self.__read_pro,'value')
        self.texts['elms'].observe(self.__read_pro,'value')
        # Link
        ipw.dlink((self.dds['elms'],'value'),(self.texts['elms'],'value'))
        ipw.dlink((self.dds['orbs'],'value'),(self.texts['orbs'],'value'))

    def update_options(self,sys_info=None):
        if sys_info:
            orbs_opts = {str(i)+': '+item:str(i) for i,item in enumerate(sys_info.fields)}
            if len(sys_info.fields) == 9:
                orbs_opts = {**orbs_opts,'1-3: p':'1-3','4-8: d':'4-8'}
            if len(sys_info.fields) == 16:
                orbs_opts = {**orbs_opts,'9-15: f':'9-15'}
            max_ind = len(sys_info.fields)-1
            orbs_opts['0-{}: All'.format(max_ind)] = "0-{}".format(max_ind)
            inds = sys_info.ElemIndex
            ions_opts = {"{}-{}: {}".format(inds[i],inds[i+1]-1,item):"{}-{}".format(
                                    inds[i],inds[i+1]-1) for i,item in enumerate(sys_info.ElemName)}
            self.dds['elms'].options = {**ions_opts,'0-{}: All'.format(inds[-1]-1):'0-{}'.format(inds[-1]-1)}
            self.dds['orbs'].options = orbs_opts
            self.sys_info = sys_info # Update it as well.

    def __read_pro(self,btn):
        def read(cell_value):
            _out = []
            for v in (cell_value.split(",") if cell_value else ''):
                if v and '-' in v:
                    i, f = [int(k) for k in v.split("-")]
                    _out = [*_out,*list(range(i,f+1))]
                elif v:
                    _out = [*_out,int(v)]
            return _out
        index = self.dds['rgb'].value
        self.output['elements'][index] = read(self.texts['elms'].value)
        self.output['orbs'][index] = read(self.texts['orbs'].value)
        _text,_ion,_orb = self.texts['label'].value,self.texts['elms'].value,self.texts['orbs'].value
        self.output['labels'][index] = _text if _text else "{}:{}".format(_ion,_orb)
        self.html.value = """<div style='border: 2px solid {0}!important;
                             background-color:{0} !important;'> </div>
                             """.format(self.dds['rgb'].label.lower())
        sleep(1)
        self.html.value = ''

    def __see_input(self,change):
        # Unobserve first to avoid overwriting
        self.texts['label'].unobserve(self.__read_pro,'value')
        self.texts['orbs'].unobserve(self.__read_pro,'value')
        self.texts['elms'].unobserve(self.__read_pro,'value')

        # Look up while not observing
        x = self.dds['rgb'].value
        self.texts['elms'].value = ','.join([str(i) for i in self.output['elements'][x]])
        self.texts['orbs'].value = ','.join([str(i) for i in self.output['orbs'][x]])
        self.texts['label'].value = self.output['labels'][x]
        # Observe Back Again
        self.texts['label'].observe(self.__read_pro,'value')
        self.texts['orbs'].observe(self.__read_pro,'value')
        self.texts['elms'].observe(self.__read_pro,'value')

    def show(self):
        return self.box

# Cell
#mouse event handler
def _click_data(sel_en_w,fermi_w,data_dict,fig,bd_w):
    def handle_click(trace, points, state):
        if(points.ys!=[]):
            e_fermi = (float(fermi_w.value) if fermi_w.value else 0)
            v_clicked = points.ys[0] if bd_w.value=='Bands' else points.xs[0]
            val = np.round(float(v_clicked) + e_fermi,4) #exact value
            for key in sel_en_w.options:
                if key in sel_en_w.value and key != 'None':
                    data_dict[key] = val # Assign value back
                if 'Fermi' in sel_en_w.value:
                    fermi_w.value = str(val) # change fermi
            # Shift Graph for Fermi value
            if 'Fermi' in sel_en_w.value:
                with fig.batch_animate():
                    for trace in fig.data: # Shift graph as Fermi Changes
                        if bd_w.value == 'Bands':
                            trace.y = [y - data_dict['Fermi'] + e_fermi for y in trace.y]
                        else:
                            trace.x = [x - data_dict['Fermi'] + e_fermi for x in trace.x]

            # Update Fermi, SO etc
            if data_dict['VBM'] and data_dict['CBM']:
                data_dict['E_gap'] = np.round(data_dict['CBM'] - data_dict['VBM'], 4)
            if data_dict['so_max'] and data_dict['so_min']:
                data_dict['Î”_SO'] = np.round(data_dict['so_max'] - data_dict['so_min'], 4)
            # Cycle energy types on graph click and chnage table as well unless it is None.
            if sel_en_w.value == 'CBM': # Avoid accidental SO calculation
                sel_en_w.value = 'None'
            if sel_en_w.value != 'None': # Keep usually as None
                _this = sel_en_w.options.index(sel_en_w.value)
                _next = _this + 1 if _this < len(sel_en_w.options) - 1 else 0
                sel_en_w.value = sel_en_w.options[_next] #To simulate as it changes

    for trace in fig.data:
        trace.on_click(handle_click)

# Display Table
def _tabulate_data(data_dict):
    new_dict = {k:v for k,v in data_dict.items() if v != '' and k not in ['sys','so_max','so_min','Fermi']}
    ls = list(new_dict.keys())
    ds = list(new_dict.values())

    if len(ls) % 2 != 0:
        ls.append('')
        ds.append('')

    tab_data = [ls[:int(len(ls)/2)],ds[:int(len(ls)/2)],ls[int(len(ls)/2):],ds[int(len(ls)/2):]]

    htm_string = """<style>table {border-collapse: collapse !important;
      min-width: 100% !important;
      margin: 1px 1px 1px 1px !important;
      font-size: small !important;
      font-family: "Times New Roman", "Times", "serif" !important;}
      th, td {text-align: center !important;
      padding: 0px 8px 0px 8px !important;}
      tr { width: 100% !important;}
      tr:nth-child(odd) {font-weight:bold !important;}
      </style>"""
    htm_string += "<table><tr>{}</tr></table>".format( '</tr><tr>'.join(
                   '<td>{}</td>'.format('</td><td>'.join(str(_) for _ in row)) for row in tab_data) )
    return htm_string

# Send Data
def _save_data(out_w1,data_dict):
    out_f = os.path.join(os.path.split(out_w1.value)[0],'result.json')
    vp.dump_dict(data_dict,dump_to='json',outfile=out_f)

# Cell
def _color_toggle(tog_w,fig,rd_btn):
    if tog_w.icon == 'toggle-off':
        tog_w.icon = 'toggle-on'
        with fig.batch_animate():
            if rd_btn.value == 'DOS':
                for trace in fig.data:
                    trace.fill='tozeroy'
            else:
                for trace in fig.data[:1]:
                    trace.mode='markers+lines'
                    trace.line.color='rgba(222,222,220,0.1)'
    else:
        tog_w.icon = 'toggle-off'
        with fig.batch_animate():
            if rd_btn.value == 'DOS':
                for trace in fig.data:
                    trace.fill=None
            else:
                for trace in fig.data[:1]:
                    trace.mode='lines'
                    trace.line.width=1.5
                    trace.line.color='skyblue'

# Cell
def generate_summary(paths_list=None):
    # Make Data Frame
    result_paths = []
    common_prefix = '' #placeholder
    if paths_list:
        common_prefix = os.path.commonprefix(paths_list)
        for item in paths_list:
            if item and os.path.isdir(item):
                result_paths.append(os.path.join(item,'result.json'))
            elif item and os.path.isfile(item):
                result_paths.append(os.path.join(os.path.split(item)[0],'result.json'))
    result_dicts = []
    for path in result_paths:
        try: _p_ = os.path.split(path)[0].split(common_prefix)[1]
        except: _p_ = '' #In current directory
        try:
            f = open(path,'r')
            l_d = json.load(f)
            l_d.update({'rel_path':_p_})
            result_dicts.append(l_d)
            f.close()
        except: pass
    out_dict = {} # placeholder
    if result_dicts:
        out_dict.update({k:[v] if v!='' else [np.nan] for k,v in result_dicts[0].items()})
        for i,d in enumerate(result_dicts):
            if i != 0:
                for k,v in d.items():
                    v = np.nan if v=='' else v
                    try: out_dict[k].append(v)
                    except:
                        out_dict.update({k:[np.nan for l in range(i)]}) #if not key before, add to all previous
                        out_dict[k].append(v) # Then append for current value
            # If next dictionary does not have key
            for k in out_dict.keys():
                if k not in d.keys():
                    out_dict[k].append(np.nan)
    try: out_dict.pop('Fermi',None) # Remove Fermi as not necessary
    except: pass

    df = pd.DataFrame(out_dict)
    if common_prefix:
        return df.style.set_caption("Root Path: {}".format(common_prefix)) # return with header
    return df #return simple

# Cell
class KPathApp:
    """View and trace path on BZ.
    - **Usage**
        > ka = KPathApp()
        > ka.show() #Display app
        > ka.splot() #get matplotlib figure
    """
    output = ipw.Output().add_class('output')
    def __init__(self,path='POSCAR'):
        self.path = path
        self.files_gui, self.files_dd = get_files_gui(auto_fill='POSCAR')
        self.files_dd.layout.width = '50%'
        self.tab = ipw.Tab([self.files_gui,Box([]),KPathApp.output])
        self.tab.add_class('marginless').add_class('borderless')
        self.tab.set_title(0,'Home')
        self.tab.set_title(1,'Main')
        self.tab.set_title(2,'STDERR')
        self.fig = go.FigureWidget()
        self.fig.layout.template = 'plotly_white' #Forces to avoid colored patch in background
        self.bz = None
        self.kpoints = []
        self.coords = []
        self.labels = []
        self.nkpts = []
        self.patches = []
        self.buttons = {'delete':Button(description='Delete Selected'),
                        'add':Button(description='Add Point'),
                        'patch':Button(description='Split Path'),
                        'check':Checkbox(description='Toggle Selection',indent=False),
                        'fig_up': Button(description='Update Figure'),
                        'theme': Checkbox(description='Dark Theme',indent=False)}
        self.checks = VBox([Checkbox() for k in self.kpoints],layout=Layout(min_height='200px'))
        self.views = VBox(self.checks.children)
        self.texts = {'label':Text(description='Label, N',indent=False),
                      'kxyz':Text(description='kx, ky, kz',indent=False)}
        self.theme_html = ipw.HTML(css_style(light_colors))

        self.buttons['delete'].on_click(self.__delete)
        self.buttons['check'].observe(self.__check_all)
        self.buttons['add'].on_click(self.__add)
        self.buttons['patch'].on_click(self.__add_patch)
        self.buttons['theme'].observe(self.__toggle_theme)
        self.buttons['fig_up'].on_click(self.__update_fig)
        self.texts['label'].on_submit(self.__label)
        self.texts['kxyz'].on_submit(self.__manual_k)

        self.__update_fig()

    @output.capture(clear_output=True,wait=True)
    def __toggle_theme(self,change):
        if self.buttons['theme'].value:
            self.theme_html.value = css_style(dark_colors)
            self.fig.layout.template = 'plotly_dark'
            self.fig.layout.paper_bgcolor = dark_colors['box_bg'] #important
        else:
            self.theme_html.value = css_style(light_colors)
            self.fig.layout.template = 'plotly_white'
            self.fig.layout.paper_bgcolor = light_colors['box_bg']

    @output.capture(clear_output=True,wait=True)
    def __manual_k(self,change):
        for i,c in enumerate(self.checks.children):
            if c.value:
                self.kpoints[i] = [float(v) for v in self.texts['kxyz'].value.split(',') if v != ''][:3]
                kp,n,l = self.kpoints[i], self.nkpts[i],self.labels[i]
                c.description = "{0:>9.4f}{1:>9.4f}{2:>9.4f} -> {3}!{4}".format(*kp,n,l)
        self.__update_selection() #Change on graph too

    @output.capture(clear_output=True,wait=True)
    def __check_all(self,change):
        for c in self.checks.children:
            if self.buttons['check'].value:
                c.value = True
            else:
                c.value = False
    @output.capture(clear_output=True,wait=True)
    def show(self):
        for k,b in self.buttons.items():
            b.layout.width = 'max-content'
        for k,t in self.texts.items():
            t.layout.width='85%'
        top_row = HBox([self.files_dd,self.buttons['fig_up']]).add_class('borderless')
        _buttons1 = HBox([self.buttons[b] for b in ['add','delete','theme']]).add_class('borderless')
        _buttons2 = HBox([self.buttons[b] for b in ['patch','check']]).add_class('borderless')
        self.tab.children = [self.tab.children[0],
                            HBox([
                                  VBox([self.theme_html,
                                        VBox([top_row,_buttons1,_buttons2],
                                        layout = Layout(min_height='140px')),
                                        Box([self.views]).add_class('marginless').add_class('borderless'),
                                        *self.texts.values()],
                                  layout=Layout(min_width='320px')).add_class('borderless'),
                                  Box([self.fig]).add_class('borderless')],
                            layout=Layout(height='400px')).add_class('borderless'),
                            self.tab.children[-1]]
        return self.tab

    @output.capture(clear_output=True,wait=True)
    def __delete(self,change):
        for i,c in enumerate(self.checks.children):
            if self.patches and c.value:
                for j,p in enumerate(self.patches):
                    if i in p:
                        self.patches[j] = range(p.start,p.stop-1)
                    if p.start > i:
                        self.patches[j] = range(p.start-1,p.stop-1)
        self.patches = [p for p in self.patches if p] #Avoid empty patches.
        self.patches = self.patches if len(self.patches) > 1 else [] # No single patch

        current = [i for i,c in enumerate(self.checks.children) if c.value]
        self.kpoints = [k for i,k in enumerate(self.kpoints) if i not in current]
        self.coords  = [c for i,c in enumerate(self.coords) if i not in current]
        self.labels  = [l for i,l in enumerate(self.labels) if i not in current]
        self.nkpts = [n for i,n in enumerate(self.nkpts) if i not in current]
        self.checks.children = [c for i,c in enumerate(self.checks.children) if i not in current]
        # Finally Update view
        self.__update_views()

    @output.capture(clear_output=True,wait=True)
    def __add(self,change):
        self.kpoints.append([])
        self.coords.append([])
        self.labels.append('')
        self.nkpts.append('')
        self.checks.children = [*self.checks.children, Checkbox(indent=False)]
        self.checks.children[-1].value = True #Add and make available
        for c in self.checks.children[:-1]: # Turn off others
            c.value = False
        if self.patches: #Update patches
            start,stop = self.patches[-1].start, self.patches[-1].stop + 1
            self.patches[-1] = range(start,stop)
        # Update view finally
        self.__update_views()

    @output.capture(clear_output=True,wait=True)
    def __add_patch(self,change):
        _splits = [0]
        for i,c in enumerate(self.checks.children):
            if c.value:
                _splits.append(i)
        if _splits[-1] != len(self.checks.children) - 1:
            _splits.append((len(self.checks.children) - 1))
        _patches = np.reshape(_splits,(-1,2))
        self.patches = [range(p[0],p[1]+1) for p in _patches]
        self.__update_views()

    @output.capture(clear_output=True,wait=True)
    def __update_views(self):
        if self.patches:
            _childs = []
            for p in self.patches:
                _childs = [*_childs,*self.checks.children[p[0]:p[-1]+1]]
                _childs.append(HTML(''.center(25,'-')))
            self.views.children = _childs[:-1]
        else:
            self.views.children = self.checks.children

    @output.capture(clear_output=True,wait=True)
    def get_coords_labels(self):
        "`coords` are calculated for current `bz` even if `kpoints` were from other one. Useful in case of same kind of Zones with just basis changed."
        if self.bz:
            coords = [sio.to_R3(self.bz.basis,kp).tolist() if kp else [] for kp in self.kpoints]
        else:
            coords = self.coords.copy()
        labels = self.labels.copy()
        j = 0
        for p in self.patches[:-1]:
            labels.insert(p.stop+j,'NaN')
            coords.insert(p.stop+j,[np.nan,np.nan,np.nan])
            j += 1

        coords = np.array([c for c in coords if c])
        labels = [l for l in labels if l]
        return coords,labels

    @output.capture(clear_output=True,wait=True)
    def __update_selection(self):
        coords,labels = self.get_coords_labels()
        with self.fig.batch_animate():
            for trace in self.fig.data:
                if 'path' in trace.name and coords.any():
                    trace.x = coords[:,0]
                    trace.y = coords[:,1]
                    trace.z = coords[:,2]
                    trace.text = labels

    @output.capture(clear_output=True,wait=True)
    def __click(self):
        def handle_click(trace, points, state):
            if points.ys != []:
                index = points.point_inds[0]
                kp = trace.hovertext[index]
                kp = [float(k) for k in kp.split('[')[1].split(']')[0].split()]
                cp = [trace.x[index],trace.y[index],trace.z[index]]
                for i,c in enumerate(self.checks.children):
                    if c.value:
                        self.kpoints[i] = kp
                        self.coords[i] = cp
                        n,l = self.nkpts[i],self.labels[i]
                        c.description = "{0:>9.4f}{1:>9.4f}{2:>9.4f} -> {3}!{4}".format(*kp,n,l)
                        ind = (i+1) % len(self.kpoints) # Next Index
                        for i,c in enumerate(self.checks.children):
                            c.value = True if i == ind else False
                        break # Must break to avoid loop overflow

                self.__update_selection()

        for trace in self.fig.data:
            if 'HSK' in trace.name:
                trace.on_click(handle_click)

    @output.capture(clear_output=True,wait=True)
    def __update_fig(self,change=None):
        if self.files_dd.value:
            self.path = self.files_dd.value
            self.bz = sio.get_bz(self.path)
            fig_data = sio.iplot_bz(self.bz,fill=False,color='red',background='rgba(1,1,1,0)')
            self.fig.data = []
            with self.fig.batch_animate():
                self.fig.add_trace(go.Scatter3d(x = [],y = [],z = [],
                    mode='lines+text+markers',name='path',text=[],
                    textfont_size=18))
                self.__update_selection() #Show previous path on current fig.
                for trace in fig_data.data:
                    self.fig.add_trace(trace)

                self.fig.layout = fig_data.layout
                self.fig.layout.autosize=True
                self.fig.layout.scene.aspectmode = 'data' #very important

            self.__click()
        self.__toggle_theme(None) #Important to let text appear correctly


    @output.capture(clear_output=True,wait=True)
    def __label(self,change):
        for i,c in enumerate(self.checks.children):
            if c.value:
                inbox = self.texts['label'].value.split(',')
                self.labels[i] = inbox[0]
                try: self.nkpts[i] = int(inbox[1])
                except: pass
                kp,n,l = self.kpoints[i] ,self.nkpts[i],self.labels[i]
                if kp:
                    c.description = "{0:>9.4f}{1:>9.4f}{2:>9.4f} -> {3}!{4}".format(*kp,n,l)
                else:
                    c.description = "____  ____  ____ -> {0}!{1}".format(n,l)
                c.value = False
                ind = (i+1) % len(self.kpoints) # Next Index
                for i,c in enumerate(self.checks.children):
                    c.value = True if i == ind else False
                self.texts['label'].value = '' # Auto delete
                self.__update_selection()
                break # Must break to avoid loop overflow

    def get_kpath(self,n=5,weight=None,ibzkpt=None,outfile=None):
        "See Docs of pp.get_kpath for details."
        kws = dict(n=n,weight=weight,ibzkpt=ibzkpt,outfile=outfile)
        if self.patches:
            kps,ns = self.kpoints, self.nkpts
            hsk_list = [[[*kps[p],ns[p]] if ns[p]!='' else kps[p] for p in ps] for ps in self.patches]
            labels = self.labels.copy()
            for p1,p2 in zip(self.patches[:-1], self.patches[1:]): #Join before last patch
                labels[p1.stop - 1] = '{}|{}'.format(labels[p1.stop - 1],labels[p2.start])
                labels[p2.start] = ''
            labels = [l for l in labels if l!='']
        else:
            hsk_list = [[*kp,n] if n!='' else kp for kp,n in zip(self.kpoints,self.nkpts)]
            labels = self.labels
        return pp.get_kpath(hsk_list=hsk_list,labels=labels,**kws)

    def splot(self,**kwargs):
        "Same as `pp.splot_bz` except it also plots path on BZ. `kwargs` are passed to `pp.splot_bz`"
        ax = sio.splot_bz(path_pos_bz=self.path,**kwargs)
        coords,labels = self.get_coords_labels()
        plane = kwargs.get('plane',None)
        if plane != None and plane in 'xyzxzyx':
            ind = 'xyzxzyx'.index(plane)
            arr = [0,1,2,0,2,1,0]
            ix,iy = arr[ind],arr[ind+1]
            coords = coords[:,[ix,iy]]
        if coords.any(): #To avoid errors if not coords
            ax.plot(*coords.T,'-o',color='blue',lw=0.8)
            _ = [ax.text(*vs,lab) for vs,lab in zip(coords,labels) if lab!='NaN']
        return ax
    def iplot(self):
        "Returns disconnected current plotly figure"
        return go.Figure(data=self.fig.data, layout=self.fig.layout)

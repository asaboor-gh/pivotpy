# AUTOGENERATED! DO NOT EDIT! File to edit: Widgets.ipynb (unless otherwise specified).

__all__ = ['css_style', 'dark_colors', 'light_colors', 'simple_colors', 'get_files_gui', 'InputGui', 'generate_summary',
           'VasprunApp', 'KPathApp']

# Cell
import os
import json
from time import sleep

# Widgets Imports
from IPython.display import display, Markdown
import ipywidgets as ipw
from ipywidgets import Layout,Label,Button,Box,HBox,VBox,Dropdown,Text,Checkbox
from ipywidgets.embed import embed_minimal_html, dependency_state

# More exports
import numpy as np
import pandas as pd
import plotly.graph_objects as go

# Inside packages import to work both with package and jupyter notebook.
try:
    from pivotpy import g_utils as gu
    from pivotpy import vr_parser as vp
    from pivotpy import i_plots as ip
    from pivotpy import s_plots as sp
    from pivotpy import sio
except:
    import pivotpy.g_utils as gu
    import pivotpy.vr_parser as vp
    import pivotpy.i_plots as ip
    import pivotpy.s_plots as sp
    import pivotpy.sio as sio

# Cell
def css_style(colors_dict):
    """Return style based on colors_dict available as pp.light_colors, pp.dark_colors etc"""
    return """<style>
    .widget-label-basic {{
        background-color: transparent !important;
        color: {text} !important;
    }}
    .widget-text input {{
        background-color: {input_bg} !important;
        border-radius:20px !important;
        padding: 0px 10px 0px 10px !important;
        border: 1px solid {input_border} !important;
        color: {input_fg} !important;
        }}
    .widget-text input:focus {{
        border: 1px solid {input_hover} !important;
        }}
    .widget-text input:hover {{
        border: 1px solid {input_hover} !important;
        }}
    .widget-dropdown > select {{
        background-color: {dd_select_bg} !important;
        border:none !important;
        border-bottom: 1px solid {input_hover} !important;
        box-shadow: inset 0 -20px 10px -20px {input_hover};
        color: {dd_select_fg} !important;
    }}
    .widget-dropdown > select:hover {{
        background-color: {dd_hover} !important;
    }}
    .widget-dropdown > select > option {{
        color: {dd_opt_fg} !important;
        background-color: {dd_opt_bg} !important;
    }}
    .widget-dropdown > select > option:focus {{
        background-color: {dd_focus_bg} !important;
    }}
    .widget-label {{
        color: {text} !important;
    }}
    .widget-html {{
        color: {text} !important;
    }}
    .widget-box {{
        background-color: {box_bg} !important;
        border-radius:5px !important;
        padding:1px !important;
        border: 1px solid {box_border} !important;
        box-shadow: 1px 1px 1px 1px {box_border} !important;
    }}
    .borderless {{
        border: 1px solid transparent !important;
        box-shadow: none !important;
        border-radius: 4px !important;
        margin:4px !important;
    }}
    .marginless {{
        margin: 0px !important;
        border-radius: 0px !important;
    }}
    .output {{
        color: {text} !important;
        background-color: inherit !important;
    }}
    .widget-tab {{
        background-color: {tab_bg} !important;
        border: none !important;
        box-shadow: 1px 1px 1px 1px {tab_shadow} !important;
        padding: 0px 2px 2px 2px !important;
    }}
    .widget-tab-contents, .widget-tab > .widget-tab-contents {{
        width: 100%;
        box-sizing: border-box;
        margin: 0px !important;
        padding: 0px !important;
        flex-grow: 1;
        overflow: auto;
        border: none !important;
        background-color: {tab_bg} !important;
    }}
    .widget-tab > .p-TabBar .p-TabBar-tab {{
        background-color:{tab_bg} !important;
        border: none !important;
        color: {tab_fg} !important;
        font-weight: bold !important;
        font-size: 16px !important;
        font-family: "Times","serif" !important;
        text-align: center !important;
    }}
    table {{
        color: {table_fg} !important;
        }}
    tr:nth-child(odd) {{
        background-color: {tr_odd_bg} !important;
        }}
    tr:nth-child(even) {{
        background-color: {tr_even_bg} !important;
        }}
    .widget-button,.widget-toggle-button {{
        color: 	{btn_fg} !important;
        min-width: max-content !important;
        background-color: {btn_bg};
        border-radius: 5px !important;
    }}
    tr:hover {{
        background-color: {tr_hover_bg} !important;
        }}
    </style>
    """.format(**colors_dict)

dark_colors = {
 'table_fg': '#ABB2BF',
 'tr_odd_bg': '#282C34',
 'tr_even_bg': '#21252B',
 'tr_hover_bg': '#414855',
 'btn_fg': '#ABB2BF',
 'btn_bg': '#3D4450',
 'tab_bg': '#21252B',
 'tab_fg': '#61AFEF',
 'tab_shadow': '#282C34',
 'box_bg': '#21252B',
 'box_border': '#282C34',
 'text': '#ABB2BF',
 'input_bg': '#282C34',
 'input_fg': '#ABB2BF',
 'input_border': '#282C34',
 'input_hover': '#414855', # For focus and hover on border, also for dd se
 'dd_select_fg': '#ABB2BF',
 'dd_select_bg': 'transparent',
 'dd_hover': '#3D4450',
 'dd_opt_bg': '#282C34',
 'dd_opt_fg': 'whitesmoke',
 'dd_focus_bg': 'green'}

light_colors = {
    'table_fg'    : 'black',
    'tr_odd_bg'   : '#eaf0f0',
    'tr_even_bg'  : 'white',
    'tr_hover_bg' : '#abe4ff',
    'btn_fg'      : 'black',
    'btn_bg'      : '#c3d4d4',
    'tab_bg'      : '#F3F3F3',
    'tab_fg'      : 'black',
    'tab_shadow'  : 'gray',
    'box_bg'      : '#F3F3F3',
    'box_border'  : 'whitesmoke',
    'text'        : 'black',
    'input_bg'    : 'white',
    'input_fg'    : 'gray',
    'input_border': '#e0e8e8',
    'input_hover' : 'skyblue', # For focus and hover on border, also for dd select
    'dd_select_fg': 'skyblue',
    'dd_select_bg': 'transparent',
    'dd_hover'    : 'white',
    'dd_opt_bg'   : '#eaf0f0',
    'dd_opt_fg'   : 'gray',
    'dd_focus_bg' : 'red'
}
simple_colors = {
    'table_fg': 'black',
    'tr_odd_bg': 'whitesmoke',
    'tr_even_bg': 'white',
    'tr_hover_bg': 'lightgray',
    'btn_fg': 'black',
    'btn_bg': 'whitesmoke',
    'tab_bg': 'white',
    'tab_fg': 'black',
    'tab_shadow': 'white',
    'box_bg': 'white',
    'box_border': 'white',
    'text': 'black',
    'input_bg': 'white',
    'input_fg': 'black',
    'input_border': 'lightgray',
    'input_hover': 'gray',
    'dd_select_fg': 'black',
    'dd_select_bg': 'transparent',
    'dd_hover': 'whitesmoke',
    'dd_opt_bg': 'white',
    'dd_opt_fg': 'black',
    'dd_focus_bg': 'white'
}

# Cell
def get_files_gui(auto_fill = 'vasprun.xml',html_style=None,height=320):
    """
    - Creates a GUI interface for files/folders filtering.
    - **Parmeters**
        - auto_fill  : Default is `vasprun.xml`, any file/folder.
        - html_style : None,Output of `css_style`.
        - height     : Height of Grid box.
    - **Returns**
        - Tuple(GUI_gridbox,Files_Dropdown). Access second one by item itself.
    """
    files_w = ipw.Dropdown(continuous_update=False)
    pw = ipw.Text(value=os.getcwd())

    incldue_w = ipw.Text(value=auto_fill)

    excldue_w = ipw.Text()
    d_layout = Layout(width='30%')
    l_layout = Layout(width='19%')
    depth_w = ipw.Dropdown(options=[None,1,2,3,4,5],value=4,layout=d_layout)
    item_w = ipw.Dropdown(options=['Both','Files','Folders'],value='Files',layout=d_layout)
    item_box = ipw.HBox([ipw.Label('Depth: ',layout=l_layout),depth_w,ipw.Label('Type: ',layout=l_layout),item_w])
    item_box.add_class('borderless').add_class('marginless')

    applybtn_w = ipw.Button(description='Apply Filters')
    gci_output = ipw.Output(layout=Layout(height='{}px'.format(height-70)))
    label_head = ipw.HTML("<h3>Your Filtered Files List</h3>")


    def filter_gci(applybtn_w):
        applybtn_w.description = 'Applying...'
        applybtn_w.disabled = True
        if os.path.isdir(pw.value):
            path = pw.value
        else:
            with gci_output:
                print("Given path does not exists.")
                print("Falling back to PWD: {}".format(os.getcwd()))
            path = os.getcwd()
            pw.value = path
        gci = vp.Dict2Data({'children':[],'parent':path})

        if 'Files' in item_w.value:
            file_type = dict(filesOnly=True)
        elif 'Folders' in item_w.value:
            file_type = dict(dirsOnly=True)
        else:
            file_type = {}
        try:
            gci = gu.get_child_items(path=path, **file_type,
                           include= incldue_w.value,
                           exclude= excldue_w.value,
                           depth=depth_w.value)
        except:
            with gci_output:
                print('Something went wrong')
        # Enable before any error occur.
        applybtn_w.disabled = False
        files_w.options = {name: os.path.join(gci.parent,name) for name in gci.children}

        applybtn_w.description = 'Successful!'
        label_head.value = "<h3>From: {}</h3>".format(gci.parent)
        with gci_output:
            display(ipw.HTML("<h4>{} files found.</h4>".format(len(gci.children))))
            display(ipw.HTML("<ol>{}<ol>".format(''.join(['<li>{}</li>'.format(i) for i in gci.children]))))


        applybtn_w.description = 'Apply Filters'
        gci_output.clear_output(wait=True)

    applybtn_w.on_click(filter_gci)
    out_box = ipw.Box([gci_output])
    right_box = ipw.VBox([label_head,out_box])
    out_box.add_class('borderless')
    right_box.add_class('borderless')
    i_layout = Layout(width='99%')
    incldue_w.layout = i_layout
    excldue_w.layout = i_layout
    pw.layout = i_layout
    input_box = ipw.VBox([
        ipw.Label('Path to Project Folder',layout=i_layout),pw,
        ipw.Label('Items to Include (separate by |)',layout=i_layout),incldue_w,
        ipw.Label('Items to Exclude (separate by |)',layout=i_layout),excldue_w,
        item_box,
        applybtn_w],layout=Layout(width='330px'))
    if not html_style:
        html_style = ''
    full_box = ipw.HBox([ipw.HTML(html_style),input_box, right_box],
                        layout=Layout(height='{}px'.format(height)))
    full_box.add_class('borderless')
    full_box.add_class('marginless')
    return full_box, files_w

# Cell
class InputGui:
    def __init__(self,sys_info=None,html_style=None,height=400):
        """
        - Creates a GUI interface for input/selection of orbitals/elms projection.
        - **Parmeters**
            - html_style : None,Output of `css_style`.
            - height     : Height of Grid box, Can set to None for auto-resizing.
            - sys_info   : `export_vasprun().sys_info`. Can change later using `self.update_options` mthod.
        - **Output Parameters**
            - output: Dictionary that contains kwargs for plot functions.
            - html  : A widget which can be used to bserve change in output, used in `VasprunApp`.
        """
        html_style = html_style if html_style else '' # Not self
        self.sys_info = sys_info if sys_info else vp.Dict2Data({'fields':['s'],
                                                'ElemIndex':[0,1],'ElemName':['A']})
        self.output = dict(elements = [[],[],[]],orbs = [[],[],[]],labels = ['','',''])

        layout = Layout(width='30%')
        l_width = Layout(width='20%')
        self.html = ipw.HTML() # For Display in Big App as well. Very important
        self.dds = {
            'elms': Dropdown(layout=layout),
            'orbs': Dropdown(layout=layout),
            'rgb' : Dropdown(options={'Red':0,'Green':1,'Blue':2},value=0,layout=layout)
            }
        self.texts = {
            'orbs' : Text(layout=layout,continuous_update=False),
            'elms' : Text(layout=layout,continuous_update=False),
            'label': Text(layout=layout,continuous_update=False)
            }
        self.update_options(self.sys_info) # In start if given

        self.box = VBox([ipw.HTML(html_style),
                self.html,
                HBox([Label('Color: ',layout=l_width), self.dds['rgb'],
                      Label('Label: ',layout=l_width),self.texts['label']
                    ]).add_class('borderless').add_class('marginless'),
                HBox([Label('Ions: ',layout=l_width),self.dds['elms'],
                      Label('::>>:: ',layout=l_width),self.texts['elms']
                    ]).add_class('borderless').add_class('marginless'),
                HBox([Label('Orbs: ',layout=l_width),self.dds['orbs'],
                      Label('::>>:: ',layout=l_width),self.texts['orbs']
                    ]).add_class('borderless').add_class('marginless')
                ],layout=Layout(height="{}px".format(height))
                ).add_class('marginless')

        #Obsever
        self.dds['rgb'].observe(self.__see_input,'value')
        self.texts['label'].observe(self.__read_pro,'value')
        self.texts['orbs'].observe(self.__read_pro,'value')
        self.texts['elms'].observe(self.__read_pro,'value')
        # Link
        ipw.dlink((self.dds['elms'],'value'),(self.texts['elms'],'value'))
        ipw.dlink((self.dds['orbs'],'value'),(self.texts['orbs'],'value'))

    def update_options(self,sys_info=None):
        if sys_info:
            orbs_opts = {str(i)+': '+item:str(i) for i,item in enumerate(sys_info.fields)}
            if len(sys_info.fields) == 9:
                orbs_opts = {**orbs_opts,'1-3: p':'1-3','4-8: d':'4-8'}
            if len(sys_info.fields) == 16:
                orbs_opts = {**orbs_opts,'9-15: f':'9-15'}
            max_ind = len(sys_info.fields)-1
            orbs_opts['0-{}: All'.format(max_ind)] = "0-{}".format(max_ind)
            inds = sys_info.ElemIndex
            ions_opts = {"{}-{}: {}".format(inds[i],inds[i+1]-1,item):"{}-{}".format(
                                    inds[i],inds[i+1]-1) for i,item in enumerate(sys_info.ElemName)}
            self.dds['elms'].options = {**ions_opts,'0-{}: All'.format(inds[-1]-1):'0-{}'.format(inds[-1]-1)}
            self.dds['orbs'].options = orbs_opts
            self.sys_info = sys_info # Update it as well.

    def __read_pro(self,btn):
        def read(cell_value):
            _out = []
            for v in (cell_value.split(",") if cell_value else ''):
                if v and '-' in v:
                    i, f = [int(k) for k in v.split("-")]
                    _out = [*_out,*list(range(i,f+1))]
                elif v:
                    _out = [*_out,int(v)]
            return _out
        index = self.dds['rgb'].value
        self.output['elements'][index] = read(self.texts['elms'].value)
        self.output['orbs'][index] = read(self.texts['orbs'].value)
        _text,_ion,_orb = self.texts['label'].value,self.texts['elms'].value,self.texts['orbs'].value
        self.output['labels'][index] = _text if _text else "{}:{}".format(_ion,_orb)
        self.html.value = """<div style='border: 2px solid {0}!important;
                             background-color:{0} !important;'> </div>
                             """.format(self.dds['rgb'].label.lower())
        sleep(1)
        self.html.value = ''

    def __see_input(self,change):
        # Unobserve first to avoid overwriting
        self.texts['label'].unobserve(self.__read_pro,'value')
        self.texts['orbs'].unobserve(self.__read_pro,'value')
        self.texts['elms'].unobserve(self.__read_pro,'value')

        # Look up while not observing
        x = self.dds['rgb'].value
        self.texts['elms'].value = ','.join([str(i) for i in self.output['elements'][x]])
        self.texts['orbs'].value = ','.join([str(i) for i in self.output['orbs'][x]])
        self.texts['label'].value = self.output['labels'][x]
        # Observe Back Again
        self.texts['label'].observe(self.__read_pro,'value')
        self.texts['orbs'].observe(self.__read_pro,'value')
        self.texts['elms'].observe(self.__read_pro,'value')

    def show(self):
        return self.box

# Cell
#mouse event handler
def _click_data(sel_en_w,fermi_w,data_dict,fig,bd_w):
    def handle_click(trace, points, state):
        if(points.ys!=[]):
            e_fermi = (float(fermi_w.value) if fermi_w.value else 0)
            v_clicked = points.ys[0] if bd_w.value=='Bands' else points.xs[0]
            val = np.round(float(v_clicked) + e_fermi,4) #exact value
            for key in sel_en_w.options:
                if key in sel_en_w.value and key != 'None':
                    data_dict[key] = val # Assign value back
                if 'Fermi' in sel_en_w.value:
                    fermi_w.value = str(val) # change fermi
            # Shift Graph for Fermi value
            if 'Fermi' in sel_en_w.value:
                with fig.batch_animate():
                    for trace in fig.data: # Shift graph as Fermi Changes
                        if bd_w.value == 'Bands':
                            trace.y = [y - data_dict['Fermi'] + e_fermi for y in trace.y]
                        else:
                            trace.x = [x - data_dict['Fermi'] + e_fermi for x in trace.x]

            # Update Fermi, SO etc
            if data_dict['VBM'] and data_dict['CBM']:
                data_dict['E_gap'] = np.round(data_dict['CBM'] - data_dict['VBM'], 4)
            if data_dict['so_max'] and data_dict['so_min']:
                data_dict['Δ_SO'] = np.round(data_dict['so_max'] - data_dict['so_min'], 4)
            # Cycle energy types on graph click and chnage table as well unless it is None.
            if sel_en_w.value == 'CBM': # Avoid accidental SO calculation
                sel_en_w.value = 'None'
            if sel_en_w.value != 'None': # Keep usually as None
                _this = sel_en_w.options.index(sel_en_w.value)
                _next = _this + 1 if _this < len(sel_en_w.options) - 1 else 0
                sel_en_w.value = sel_en_w.options[_next] #To simulate as it changes

    for trace in fig.data:
        trace.on_click(handle_click)

# Display Table
def _tabulate_data(data_dict):
    new_dict = {k:v for k,v in data_dict.items() if v != '' and k not in ['sys','so_max','so_min','Fermi']}
    ls = list(new_dict.keys())
    ds = list(new_dict.values())

    if len(ls) % 2 != 0:
        ls.append('')
        ds.append('')

    tab_data = [ls[:int(len(ls)/2)],ds[:int(len(ls)/2)],ls[int(len(ls)/2):],ds[int(len(ls)/2):]]

    htm_string = """<style>table {border-collapse: collapse !important;
      min-width: 100% !important;
      margin: 1px 1px 1px 1px !important;
      font-size: small !important;
      font-family: "Times New Roman", "Times", "serif" !important;}
      th, td {text-align: center !important;
      padding: 0px 8px 0px 8px !important;}
      tr { width: 100% !important;}
      tr:nth-child(odd) {font-weight:bold !important;}
      </style>"""
    htm_string += "<table><tr>{}</tr></table>".format( '</tr><tr>'.join(
                   '<td>{}</td>'.format('</td><td>'.join(str(_) for _ in row)) for row in tab_data) )
    return htm_string

# Send Data
def _save_data(out_w1,data_dict):
    out_f = os.path.join(os.path.split(out_w1.value)[0],'result.json')
    vp.dump_dict(data_dict,dump_to='json',outfile=out_f)

# Cell
def _color_toggle(tog_w,fig,rd_btn):
    if tog_w.icon == 'toggle-off':
        tog_w.icon = 'toggle-on'
        with fig.batch_animate():
            if rd_btn.value == 'DOS':
                for trace in fig.data:
                    trace.fill='tozeroy'
            else:
                for trace in fig.data[:1]:
                    trace.mode='markers+lines'
                    trace.line.color='rgba(222,222,220,0.1)'
    else:
        tog_w.icon = 'toggle-off'
        with fig.batch_animate():
            if rd_btn.value == 'DOS':
                for trace in fig.data:
                    trace.fill=None
            else:
                for trace in fig.data[:1]:
                    trace.mode='lines'
                    trace.line.width=1.5
                    trace.line.color='skyblue'

# Cell
def generate_summary(paths_list=None):
    # Make Data Frame
    result_paths = []
    common_prefix = '' #placeholder
    if paths_list:
        common_prefix = os.path.commonprefix(paths_list)
        for item in paths_list:
            if item and os.path.isdir(item):
                result_paths.append(os.path.join(item,'result.json'))
            elif item and os.path.isfile(item):
                result_paths.append(os.path.join(os.path.split(item)[0],'result.json'))
    result_dicts = []
    for path in result_paths:
        try: _p_ = os.path.split(path)[0].split(common_prefix)[1]
        except: _p_ = '' #In current directory
        try:
            f = open(path,'r')
            l_d = json.load(f)
            l_d.update({'rel_path':_p_})
            result_dicts.append(l_d)
            f.close()
        except: pass
    out_dict = {} # placeholder
    if result_dicts:
        out_dict.update({k:[v] if v!='' else [np.nan] for k,v in result_dicts[0].items()})
        for i,d in enumerate(result_dicts):
            if i != 0:
                for k,v in d.items():
                    v = np.nan if v=='' else v
                    try: out_dict[k].append(v)
                    except:
                        out_dict.update({k:[np.nan for l in range(i)]}) #if not key before, add to all previous
                        out_dict[k].append(v) # Then append for current value
            # If next dictionary does not have key
            for k in out_dict.keys():
                if k not in d.keys():
                    out_dict[k].append(np.nan)
    try: out_dict.pop('Fermi',None) # Remove Fermi as not necessary
    except: pass

    df = pd.DataFrame(out_dict)
    if common_prefix:
        return df.style.set_caption("Root Path: {}".format(common_prefix)) # return with header
    return df #return simple

# Cell
class VasprunApp:
    """
    Display a GUI for vasp output analysis. `self.theme_colors` can be used to edit custom theme.
    - **Usage Example**

    ```python
    import pivotpy as pp
    va = pp.VasprunApp()
    va.cache_data = False #Turn off cache globally.
    va.evr_kws['elim'] = [-2,2] #Only Bands in this range will be included. Global accross project, can change anytime.
    va.evr_kws['try_pwsh'] = False #Defult is True. Tries to load Powershell exported data.
    va.ibands_kws['mode'] = 'bands' #Change graph mode from 'markers' to 'bands'. Setting it to 'lines' is not recommended in live graph, it could hang all UI.
    va.show() #Displays App and do work!
    va.theme_colors = pp.dark_colors #Set theme to dark externally and edit dictionary values to make your own theme
    va.splot(**kwargs) #Get matplotlib plot of current data.
    va.df #After you do some analysis and hit `Project Summary` button, get DataFrame.
    va.fig #Get current fig in Notebook cell.
    ```
    """
    output = ipw.Output().add_class('output')
    def __init__(self,height=580):
        self.height = height
        tab = ipw.Tab(layout = ipw.Layout(min_height=f'{height}px', max_height='100vh',
                                           min_width='700px', max_width='100vw')
            ).add_class('marginless').add_class('borderless') # Main Tab

        for i,item in enumerate(['Home','Graphs','STD(out/err)']):
            tab.set_title(i,item)

        self.tab    = tab # Main layout
        self.data   = None # Export vasprun object.
        self.__path = None # current path
        self.fig    = go.FigureWidget() # plotly's figure widget
        self.fig.update_layout(autosize=True)
        self.df     = None # Summary DataFrame
        self.result = {'sys':'','V':'','a':'','b':'','c':'','Fermi': None,
                     'VBM':'','CBM':'','so_max':'','so_min':''} # Table widget value

        self.files_gui,self.files_dd = get_files_gui(height=300)
        self.InGui  = InputGui(height=None)
        self.input  = {'E_Fermi':0} # Dictionary for input
        self.fig_gui = HBox() # Middle Tab
        self.theme_colors = light_colors.copy() # Avoid Modification
        # Permeannet Parameters
        self.idos_kws   = dict(colormap='RGB',tdos_color=(0.5, 0.95, 0),linewidth=2,fill_area=True,
                               spin='both',interp_nk={},title=None)
        self.ibands_kws = dict(mode='markers',skipk=None,max_width=6,title=None,interp_nk={})
        self.evr_kws = dict(skipk=None,elim=[],try_pwsh = True)
        self.cache_data = True

        l_btn = ipw.Layout(width='max-content')
        self.buttons = {'load_data' : Button(description='Load Data',layout=l_btn,tooltip='Load and Cache Data'),
                        'load_graph': Button(description='Load Graph',layout=l_btn,tooltip='Create Graph'),
                        'confirm'   : Button(description='Confirm Delete',layout=l_btn,icon='trash'),
                        'summary'   : Button(description='Project Summary',layout=l_btn,tootltip='Make DataFrame'),
                        'expand'    : Button(icon = "fa-expand",layout=l_btn,tooltip='Expand Fig'),
                        'toggle'    : Button(description='RGB',layout=l_btn,icon='toggle-on',tooltip='Toggle Colors'),
                        'save_fig'  : Button(description='Save Fig',icon='download',layout=l_btn,tooltip='')
                        }

        b_out = Layout(width='30%')
        en_options = ['Fermi','VBM','CBM','so_max','so_min','None']
        self.dds   = {'band_dos': Dropdown(options=['Bands','DOS'],value='Bands',
                                                layout= Layout(width='80px')),
                      'en_type' : Dropdown(options = en_options,value='None',layout=b_out),
                      'cache'   : Dropdown(options=['Table Data','PWD Cache','All Cache','None'],
                                            value='None',layout=b_out),
                      'theme'   : Dropdown(options=['Default','Light','Dark','Custom'],
                                            value='Light',layout=l_btn),
                      'style'   : Dropdown(options=["plotly", "plotly_white", "plotly_dark",
                                    "ggplot2", "seaborn", "simple_white", "none"],layout=l_btn),
                                    }

        self.texts = {'kticks': Text(value='',layout=b_out,continuous_update=False),
                      'ktickv': Text(value='',layout=b_out,continuous_update=False),
                      'kjoin' : Text(value='',layout=b_out,continuous_update=False),
                      'elim'  : Text(value='',layout=b_out,continuous_update=False),
                      'fermi' : Text(value='',layout=b_out,continuous_update=False),
                      'xyt'   : Text(value='',continuous_update=False)
                      }

        self.htmls = {'theme': ipw.HTML(css_style(light_colors)),
                      'table': ipw.HTML()}

        # Observing
        self.InGui.html.observe(self.__update_input,"value")
        self.dds['band_dos'].observe(self.__update_input,"value")
        self.texts['fermi'].observe(self.__update_input,"value")
        self.texts['kjoin'].observe(self.__update_input,"value")
        self.texts['kticks'].observe(self.__update_xyt,"value")
        self.texts['ktickv'].observe(self.__update_xyt,"value")
        self.texts['elim'].observe(self.__update_xyt,"value")
        self.texts['xyt'].observe(self.__update_xyt)
        self.dds['theme'].observe(self.__update_theme,"value")
        self.dds['style'].observe(self.__update_plot_style,"value")
        self.files_dd.observe(self.__load_previous,"value")
        self.buttons['load_data'].on_click(self.__on_load)
        self.dds['band_dos'].observe(self.__figure_tab,"value")
        self.files_dd.observe(self.__update_table,'value')
        self.buttons['load_data'].observe(self.__update_table,'value')
        self.buttons['summary'].on_click(self.__df_out)
        self.buttons['confirm'].on_click(self.__deleter)
        self.buttons['toggle'].on_click(self.__tog_b)
        self.buttons['save_fig'].on_click(self.__save_connected)
        self.buttons['expand'].on_click(self.__expand_fig)
        self.buttons['load_graph'].on_click(self.__update_graph)
        self.dds['en_type'].observe(self.__update_table,"value") # This works from _click_data

    def __setattr__(self,name,value):
        self.__dict__[name] = value
        # Special treatment while setting theme_colors from outside.
        if name == 'theme_colors':
            if 'dds' in self.__dict__.keys():
                self.dds['theme'].value = 'Custom'
            if 'htmls' in self.__dict__.keys():
                self.htmls['theme'].value = css_style(self.theme_colors)

    def __figure_tab(self,change):
        l_out = Layout(width='20%')
        cache_box = HBox([Label('Delete Cache:'),self.dds['cache'],self.buttons['confirm']]
                        ).add_class('marginless')
        upper_box = VBox([
                HBox([Label('File:',layout=Layout(width='50px')),self.files_dd
                    ]).add_class('borderless').add_class('marginless'),
                HBox([Label('View:',layout=Layout(width='50px')),
                        self.dds['band_dos'],self.buttons['load_data']
                    ]).add_class('borderless').add_class('marginless')
                ]).add_class('marginless').add_class('borderless')

        points_box = HBox([Box([Label('E Type:',layout=l_out),
                                self.dds['en_type'],
                                Label('E-Fermi:',layout=l_out),
                                self.texts['fermi']
                    ]).add_class('marginless').add_class('borderless'),
                    self.buttons['load_graph']
                    ],layout=Layout(width='100%')).add_class('marginless')
        in_box = VBox([self.InGui.box,
                    ]).add_class('marginless').add_class('borderless')
        top_right = HBox([self.buttons['load_graph'],
                          Label('Style:'),
                          self.dds['style'],
                          Label('Theme:'),
                          self.dds['theme'],
                          self.buttons['expand']
                    ]).add_class('marginless')
        fig_box = Box([self.fig],layout=Layout(min_height='380px')).add_class('marginless')
        right_box = VBox([top_right,fig_box,self.htmls['table']
                 ],layout=Layout(min_width='60%')).add_class('marginless').add_class('borderless')


        if 'Bands' in self.dds['band_dos'].value:
            in_box.children = [Label('---------- Projections ----------'),self.InGui.box,
                               Label('---- Other Arguments/Options ----'),
                      VBox([HBox([Label('Ticks At: ',layout=l_out),
                                  self.texts['kticks'],
                                  Label('Labels: ',layout=l_out),
                                  self.texts['ktickv']
                                 ]).add_class('borderless').add_class('marginless'),
                      HBox([Label('Join At: ',layout=l_out),
                            self.texts['kjoin'],
                            Label('E Range: ',layout=l_out),
                            self.texts['elim']
                           ]).add_class('marginless').add_class('borderless')
                      ]).add_class('marginless')]
            right_box.children = [top_right,fig_box,points_box]
            self.buttons['toggle'].description = 'RGB'
        else:
            in_box.children = [Label('---------- Projections ----------'),self.InGui.box,
                               Label('---- Other Arguments/Options ----'),
                      HBox([Label('E Range:',layout=l_out),
                      self.texts['elim'],
                      Label('E-Fermi:',layout=l_out),
                      self.texts['fermi']
                      ]).add_class('marginless')]
            right_box.children = [top_right,fig_box,points_box]
            self.dds['en_type'].value = 'None' # no scatter collection in DOS.
            self.buttons['toggle'].description = 'Fill'


        left_box = VBox([upper_box,
                        in_box,
                        HBox([Label('X, Y, Title'),self.texts['xyt']]).add_class('borderless'),
                        HBox([Label('Options:'),self.buttons['summary'],self.buttons['save_fig'],self.buttons['toggle']]),
                        cache_box,
                        self.htmls['table']],layout=Layout(max_width='40%'),
                        ).add_class('marginless').add_class('borderless')
        self.fig_gui.children = (left_box,right_box)
        self.buttons['load_graph'].icon = 'fa-refresh'
        return self.fig_gui # Return for use in show

    @output.capture()
    def show(self):
        intro_html = ipw.HTML("<h2>Pivotpy</h2><p>Filter files here and switch tab to Graphs. You can create cache ahead of time to load quickly while working. If anything does not seem to work, see the error in STD(out/err) tab. For large files, do `Export-VaspRun` in Powershell to access fast. <a href=https://massgh.github.io/pivotpy/Widgets.html#VasprunApp target='_blank'>See More</a></p><marquee style='color:blue'>Pivotpy GUI based on ipywidgets!</marquee>")
        header_box = HBox([intro_html,
                           Label('Theme:',layout=Layout(width='80px')),
                           self.dds['theme']
                    ]).add_class('marginless').add_class('borderless')
        summary_gui = HBox([ipw.Label(),
                            self.buttons['summary']]
                            ).add_class('borderless')
        intro_box = VBox([self.htmls['theme'],
                      header_box,
                      self.files_gui,
                      summary_gui]
                      ).add_class('marginless').add_class('borderless').add_class('marginless')
        self.fig_gui = self.__figure_tab(1) #Start
        self.tab.children = (intro_box,
                             self.fig_gui,
                             VBox([HBox([ipw.HTML("<h3>Functions Logging/Output</h3>"),
                                          Box([
                                          Label('Theme:',layout=Layout(width='80px')),
                                          self.dds['theme']],layout=Layout(left='50%')).add_class('borderless')
                                          ]).add_class('borderless').add_class('marginless'),
                                    VasprunApp.output])
                             )
        self.dds['style'].value = 'plotly' # to trigger first callback on graph.
        return self.tab

    def __fill_ticks(self):
        kpath = os.path.join(os.path.split(self.files_dd.value)[0],'KPOINTS')
        tvs = sio.read_ticks(kpath) #ticks values segments
        if tvs['ktick_inds']: #If is must, if not present, avoid overwritting custom input
            self.texts['kticks'].value = ','.join([str(v) for v in tvs['ktick_inds']])
        if tvs['ktick_vals']:
            self.texts['ktickv'].value = ','.join(tvs['ktick_vals'])
        if tvs['kseg_inds']:
            self.texts['kjoin'].value = ','.join([str(v) for v in tvs['kseg_inds']])

    def __update_theme(self,change):
        if self.dds['theme'].value == 'Dark':
            self.htmls['theme'].value = css_style(dark_colors)
            self.fig.update_layout(template='plotly_dark')
            self.dds['style'].value = 'plotly_dark'
        elif self.dds['theme'].value == 'Light':
            self.htmls['theme'].value = css_style(light_colors)
            self.fig.update_layout(template='ggplot2')
            self.dds['style'].value = 'ggplot2'
        elif self.dds['theme'].value == 'Custom':
            self.htmls['theme'].value = css_style(simple_colors)
            self.fig.update_layout(template='none')
            self.dds['style'].value = 'none'
        else:
            self.htmls['theme'].value = ''
            self.fig.update_layout(template='plotly')
            self.dds['style'].value = 'plotly'

    def __update_plot_style(self,change):
        self.fig.update_layout(template = self.dds['style'].value)

    @output.capture(clear_output=True,wait=True)
    def __load_previous(self,change):
        path = self.files_dd.value
        try:
            _dir = os.path.split(path)[0]
            r_f = os.path.join(_dir,'result.json')
            self.result = vp.load_from_dump(r_f,keep_as_dict=True)
            print('Previous Analysis loaded in Table for {}'.format(path))
        except:
            print('Previous Analysis does not exist for {}'.format(path))

    @output.capture(clear_output=True,wait=True)
    def __read_data(self,poscar=None,sys_info=None):
        if sys_info != None:
            self.result["sys"] = sys_info.SYSTEM
        if poscar != None:
            self.result["V"] = np.round(poscar.volume,5)
            a,b,c = np.round(np.linalg.norm(poscar.basis,axis=1),5)
            self.result["a"] = a
            self.result["b"] = b
            self.result["c"] = c

    @output.capture(clear_output=True,wait=True)
    def __on_load(self,button):
        self.__fill_ticks() # First fill ticks, then update input
        self.__update_input(change=None) # Fix input right here.
        self.__load_previous(change=button) # previous calculations.
        self.tab.selected_index = 2
        self.buttons['load_data'].description='Loading ...'
        _dir = os.path.split(self.files_dd.value)[0] # directory
        try:
            sys_info = vp.load_from_dump(os.path.join(_dir,'sys_info.pickle'))
            self.data = vp.load_from_dump(os.path.join(_dir,'vasprun.pickle'))
            print('Cache Loaded')
        except:
            print('Trying Loading from Python ...')
            self.data = vp.export_vasprun(self.files_dd.value, **self.evr_kws)
            if self.cache_data:
                print('Caching From: {}'.format(self.files_dd.value)) #Cache result
                vp.dump_dict(self.data.sys_info,outfile=os.path.join(_dir,'sys_info.pickle'))
                vp.dump_dict(self.data,outfile=os.path.join(_dir,'vasprun.pickle'))

            sys_info = self.data.sys_info # required here.
            print('Done')

        _ = self.__read_data(self.data.poscar,sys_info) # Update Table data on load
        self.texts['fermi'].value = str(sys_info.E_Fermi) # Needs each time new data loads up.

        self.tab.selected_index = 1
        # Revamp input dropdowns on load  ==========
        self.InGui.update_options(sys_info=sys_info) #Upadate elements/orbs/labels
        #===========================================
        self.buttons['load_data'].description='Load Data'
        self.__path = self.files_dd.value # Update in __on_load or graph to make sure data loads once
        self.buttons['load_data'].tooltip = "Current System\n{!r}".format(self.data.sys_info)
        self.buttons['load_graph'].icon = 'fa-refresh'

    @output.capture(clear_output=True,wait=True)
    def __update_input(self,change):
        self.input.update(self.InGui.output)
        elim_str  = [v for v in self.texts['elim'].value.split(',') if v!='']
        fermi_str = self.texts['fermi'].value
        self.input['E_Fermi'] = float(fermi_str) if fermi_str else 0 # Change now, keep zero else must.
        self.input['elim'] = [float(v) for v in elim_str if v!='-'][:2] if len(elim_str) >= 2 else None
        if self.dds['band_dos'].value == 'Bands':
            kjoin_str  = [v for v in self.texts['kjoin'].value.split(',') if v!='']
            kticks_str = [v for v in self.texts['kticks'].value.split(',') if v!='']
            ktickv_str = [v for v in self.texts['ktickv'].value.split(',') if v!='']
            self.input['kseg_inds'] = [int(v) for v in kjoin_str if v!='-'] if kjoin_str else None
            self.input['ktick_inds'] = [int(v) for v in kticks_str if v!='-'] if kticks_str else [0,-1]
            self.input['ktick_vals'] = [v for v in ktickv_str if v!=''] if ktickv_str else ['A','B']
        else:
            self.input = {k:v for k,v in self.input.items() if k not in ['ktick_inds','ktick_vals','kseg_inds']}
        #Update at last
        self.InGui.output = self.input
        self.buttons['load_graph'].tooltip = "Current Input\n{!r}".format(vp.Dict2Data(self.input))
        self.buttons['load_graph'].icon = 'fa-refresh'

    @output.capture(clear_output=True,wait=True)
    def __update_table(self,change):
        self.htmls['table'].value = _tabulate_data(self.result)
        _save_data(self.files_dd,self.result) # save data as well.

    @output.capture(clear_output=True,wait=True)
    def __df_out(self,btn):
        self.tab.selected_index = 2
        self.buttons['summary'].description = 'See STD(out/err) Tab'
        paths = [v for k,v in self.files_dd.options.items()]
        df = generate_summary(paths_list=paths)
        display(df)
        self.df = df # Assign
        print('Get above DataFrame by app_name.df\nNote: app_name is variable name assigned to VasprunApp()')
        print('==================== OR =========================')
        _code = "import pivotpy as pp\npaths = ['{}']\ndf = pp.generate_summary(paths_list=paths)\ndf".format("',\n         '".join([str(p).replace('\\','/') for p in paths]))
        _code += "\n#ax = pp.init_figure()\n#df.plot(ax=ax,x='sys',y=['V','a'])"
        display(Markdown("```python\n{}\n```".format(_code)))
        self.buttons['summary'].description = 'Project Summary'

    @output.capture(clear_output=True,wait=True)
    def __deleter(self,btn):
        self.buttons['confirm'].description = 'Deleting ...'
        if self.files_dd.value:
            print('Deleting Selected Cache...')
            self.__clear_cache() # Deleting
            print('Done')
        self.__update_table(1) #Update when delete data
        self.buttons['confirm'].description='Confirm Delete'

    @output.capture(clear_output=True,wait=True)
    def __update_xyt(self,change):
        if self.texts['xyt'].value:
            xyt_text = self.texts['xyt'].value.split(',')
            try:
                self.fig.update_xaxes(title=xyt_text[0])
                self.fig.update_yaxes(title=xyt_text[1])
                self.fig.update_layout(title=xyt_text[2])
            except: pass #do nothing else

        if self.texts['ktickv'].value or self.texts['kticks'].value or self.texts['elim'].value:
            self.__update_input(change=None)
        if self.dds['band_dos'].value == 'Bands' and self.data:
            tickvals = [self.data.kpath[i] for i in self.input['ktick_inds']]
            self.fig.update_xaxes(ticktext=self.input['ktick_vals'], tickvals=tickvals)
        if self.texts['elim'].value and self.input['elim'] != None and len(self.input['elim']) == 2:
            if self.dds['band_dos'].value == 'Bands':
                self.fig.update_yaxes(range = self.input['elim'])
            else:
                self.fig.update_xaxes(range = self.input['elim'])

    @output.capture(clear_output=True,wait=True)
    def __tog_b(self,tog_w):
        _color_toggle(self.buttons['toggle'],self.fig,self.dds['band_dos'])

    @output.capture(clear_output=True,wait=True)
    def __save_connected(self,btn):
        s_p = os.path.split(self.files_dd.value)[0]
        filename = os.path.join(s_p,'ConnectedFig.html')
        filename = gu.prevent_overwrite(filename)
        self.buttons['save_fig'].description = 'Saving...'
        views = VBox([self.htmls['theme'],self.fig,self.htmls['table']],
                layout=Layout(width='500px',height='490px')).add_class('borderless')
        embed_minimal_html(filename, views=[views], state=dependency_state([views]))
        self.buttons['save_fig'].description = 'Save Fig'
        self.buttons['save_fig'].tooltip = 'Recently Saved\n{!r}'.format(filename)

    @output.capture(clear_output=True,wait=True)
    def __expand_fig(self,btn):
        self.tab.selected_index = 2
        self.dds['en_type'].value = 'None' # To avoid accidental clicks
        display(self.fig)
    # Garph
    @output.capture(clear_output=True,wait=True)
    def __update_graph(self,btn):
        path = self.files_dd.value
        if path:
            self.__fill_ticks() # First fill ticks, then update input
            self.__update_input(change=None) # Update input here as well
            self.tab.selected_index = 2
            self.fig.data = []
            if self.data and path == self.__path: # Same load and data exists, heeps in fast
                print('Data already loaded')
            else:
                try:
                    self.buttons['load_graph'].description = 'Loading pickle...'
                    print('Trying to Load Cache for Graph ...')
                    file = os.path.join(os.path.split(path)[0],'vasprun.pickle')
                    self.buttons['load_graph'].description = file
                    self.data = vp.load_from_dump(file)
                    self.buttons['load_graph'].description = 'Load Graph'
                except:
                    self.buttons['load_graph'].description = 'Loading export...'
                    print('No cache found. Loading from file {} ...'.format(path))
                    self.data = vp.export_vasprun(path, **self.evr_kws)
                self.buttons['load_graph'].description = "Load Graph"

            print('Done')

            self.__path  = self.files_dd.value #update here or __on_load. Useful to match things
            self.buttons['load_graph'].description = 'Load Graph'
            _ = self.__read_data(self.data.poscar,self.data.sys_info) # Update Table data
            # Do Not Read Fermi, its 0 or given by user
            if self.dds['band_dos'].value == 'Bands':
                fig_data = ip.iplot_rgb_lines(path_evr=self.data,**self.input,**self.ibands_kws)
            else:
                self.dds['en_type'].value = 'None' # Avoid random clicks
                fig_data = ip.iplot_dos_lines(path_evr=self.data,**self.input,**self.idos_kws) # input auto-modified

            self.tab.selected_index = 1
            with self.fig.batch_animate():
                for d in fig_data.data:
                    self.fig.add_trace(d)
                fig_data.layout.template = self.dds['style'].value # before layout to avoid color blink
                self.fig.layout = fig_data.layout

            _click_data(self.dds['en_type'],self.texts['fermi'],self.result,self.fig,self.dds['band_dos'])
            self.buttons['load_graph'].icon = 'fa-check'

    @output.capture(clear_output=True,wait=True)
    def __clear_cache(self):
        self.tab.selected_index = 2
        _dir = os.path.split(self.files_dd.value)[0]
        if 'Table' in self.dds['cache'].value:
            for k in self.result.keys(): # Avoid deleting V,a,b,Fermi
                if k not in ['sys','V','a','b','c','Fermi']:
                    self.result[k] = ''
        if 'PWD' in self.dds['cache'].value:
            _files = [os.path.join(_dir,f) for f in ['sys_info.pickle','vasprun.pickle']]
            _ = [[print("Deleting", _file),os.remove(_file)] for _file in _files if os.path.isfile(_file)]
        if 'All' in self.dds['cache'].value:
            for key, value in self.files_dd.options.items():
                _dir = os.path.split(value)[0]
                _files = [os.path.join(_dir,f) for f in ['sys_info.pickle','vasprun.pickle']]
                _ = [[print("Deleting", _file),os.remove(_file)] for _file in _files if os.path.isfile(_file)]
        self.tab.selected_index = 1

    def iplot(self,**kwargs):
        "Returns a detached interactive Figure. `kwargs` are passed to `iplot_rgb_lines` or `iplot_dos_lines` based on current figure. `kwargs` should exclude whatever inside `self.input` and `path_evr`"
        kwargs = {k:v for k,v in kwargs.items() if k not in self.input.keys() or k!='path_evr'}
        if self.dds['band_dos'].value == 'Bands':
            return ip.iplot_rgb_lines(path_evr=self.data,**self.input,**kwargs)
        else:
            return ip.iplot_dos_lines(path_evr=self.data,**self.input,**kwargs)

    def splot(self,**kwargs):
        "Returns matplotlib Axes.`kwargs` are passed to `splot_rgb_lines` or `splot_dos_lines` based on current figure. `kwargs` should exclude whatever inside `self.input` and `path_evr`"
        kwargs = {k:v for k,v in kwargs.items() if k not in self.input.keys() or k!='path_evr'}
        if self.dds['band_dos'].value == 'Bands':
            return sp.splot_rgb_lines(path_evr=self.data,**self.input,**kwargs)
        else:
            return sp.splot_dos_lines(path_evr=self.data,**self.input,**kwargs)

# Cell
class KPathApp:
    """View and trace path on BZ.
    - **Usage**
        > ka = KPathApp()
        > ka.show() #Display app
        > ka.splot() #get matplotlib figure
    """
    output = ipw.Output().add_class('output')
    def __init__(self,path='POSCAR'):
        self.path = path
        self.files_gui, self.files_dd = get_files_gui(auto_fill='POSCAR')
        self.files_dd.layout.width = '50%'
        self.tab = ipw.Tab([self.files_gui,Box([]),KPathApp.output])
        self.tab.add_class('marginless').add_class('borderless')
        self.tab.set_title(0,'Home')
        self.tab.set_title(1,'Main')
        self.tab.set_title(2,'STDERR')
        self.fig = go.FigureWidget()
        self.fig.layout.template = 'plotly_white' #Forces to avoid colored patch in background
        self.bz = None
        self.kpoints = []
        self.coords = []
        self.labels = []
        self.nkpts = []
        self.patches = []
        self.buttons = {'delete':Button(description='Delete Selected'),
                        'add':Button(description='Add Point'),
                        'patch':Button(description='Split Path'),
                        'check':Checkbox(description='Toggle Selection',indent=False),
                        'fig_up': Button(description='Update Figure'),
                        'theme': Checkbox(description='Dark Theme',indent=False)}
        self.checks = VBox([Checkbox() for k in self.kpoints],layout=Layout(min_height='200px'))
        self.views = VBox(self.checks.children)
        self.texts = {'label':Text(description='Label, N',indent=False),
                      'kxyz':Text(description='kx, ky, kz',indent=False)}
        self.theme_html = ipw.HTML(css_style(light_colors))

        self.buttons['delete'].on_click(self.__delete)
        self.buttons['check'].observe(self.__check_all)
        self.buttons['add'].on_click(self.__add)
        self.buttons['patch'].on_click(self.__add_patch)
        self.buttons['theme'].observe(self.__toggle_theme)
        self.buttons['fig_up'].on_click(self.__update_fig)
        self.texts['label'].on_submit(self.__label)
        self.texts['kxyz'].on_submit(self.__manual_k)

        self.__update_fig()

    @output.capture(clear_output=True,wait=True)
    def __toggle_theme(self,change):
        if self.buttons['theme'].value:
            self.theme_html.value = css_style(dark_colors)
            self.fig.layout.template = 'plotly_dark'
            self.fig.layout.paper_bgcolor = dark_colors['box_bg'] #important
        else:
            self.theme_html.value = css_style(light_colors)
            self.fig.layout.template = 'plotly_white'
            self.fig.layout.paper_bgcolor = light_colors['box_bg']

    @output.capture(clear_output=True,wait=True)
    def __manual_k(self,change):
        for i,c in enumerate(self.checks.children):
            if c.value:
                self.kpoints[i] = [float(v) for v in self.texts['kxyz'].value.split(',') if v != ''][:3]
                kp,n,l = self.kpoints[i], self.nkpts[i],self.labels[i]
                c.description = "{0:>9.4f}{1:>9.4f}{2:>9.4f} -> {3}!{4}".format(*kp,n,l)
        self.__update_selection() #Change on graph too

    @output.capture(clear_output=True,wait=True)
    def __check_all(self,change):
        for c in self.checks.children:
            if self.buttons['check'].value:
                c.value = True
            else:
                c.value = False
    @output.capture(clear_output=True,wait=True)
    def show(self):
        for k,b in self.buttons.items():
            b.layout.width = 'max-content'
        for k,t in self.texts.items():
            t.layout.width='85%'
        top_row = HBox([self.files_dd,self.buttons['fig_up']]).add_class('borderless')
        _buttons1 = HBox([self.buttons[b] for b in ['add','delete','theme']]).add_class('borderless')
        _buttons2 = HBox([self.buttons[b] for b in ['patch','check']]).add_class('borderless')
        self.tab.children = [self.tab.children[0],
                            HBox([
                                  VBox([self.theme_html,
                                        VBox([top_row,_buttons1,_buttons2],
                                        layout = Layout(min_height='140px')),
                                        Box([self.views]).add_class('marginless').add_class('borderless'),
                                        *self.texts.values()],
                                  layout=Layout(min_width='320px')).add_class('borderless'),
                                  Box([self.fig]).add_class('borderless')],
                            layout=Layout(height='400px')).add_class('borderless'),
                            self.tab.children[-1]]
        return self.tab

    @output.capture(clear_output=True,wait=True)
    def __delete(self,change):
        for i,c in enumerate(self.checks.children):
            if self.patches and c.value:
                for j,p in enumerate(self.patches):
                    if i in p:
                        self.patches[j] = range(p.start,p.stop-1)
                    if p.start > i:
                        self.patches[j] = range(p.start-1,p.stop-1)
        self.patches = [p for p in self.patches if p] #Avoid empty patches.
        self.patches = self.patches if len(self.patches) > 1 else [] # No single patch

        current = [i for i,c in enumerate(self.checks.children) if c.value]
        self.kpoints = [k for i,k in enumerate(self.kpoints) if i not in current]
        self.coords  = [c for i,c in enumerate(self.coords) if i not in current]
        self.labels  = [l for i,l in enumerate(self.labels) if i not in current]
        self.nkpts = [n for i,n in enumerate(self.nkpts) if i not in current]
        self.checks.children = [c for i,c in enumerate(self.checks.children) if i not in current]
        # Finally Update view
        self.__update_views()

    @output.capture(clear_output=True,wait=True)
    def __add(self,change):
        self.kpoints.append([])
        self.coords.append([])
        self.labels.append('')
        self.nkpts.append('')
        self.checks.children = [*self.checks.children, Checkbox(indent=False)]
        self.checks.children[-1].value = True #Add and make available
        for c in self.checks.children[:-1]: # Turn off others
            c.value = False
        if self.patches: #Update patches
            start,stop = self.patches[-1].start, self.patches[-1].stop + 1
            self.patches[-1] = range(start,stop)
        # Update view finally
        self.__update_views()

    @output.capture(clear_output=True,wait=True)
    def __add_patch(self,change):
        _splits = [0]
        for i,c in enumerate(self.checks.children):
            if c.value:
                _splits.append(i)
        if _splits[-1] != len(self.checks.children) - 1:
            _splits.append((len(self.checks.children) - 1))
        _patches = np.reshape(_splits,(-1,2))
        self.patches = [range(p[0],p[1]+1) for p in _patches]
        self.__update_views()

    @output.capture(clear_output=True,wait=True)
    def __update_views(self):
        if self.patches:
            _childs = []
            for p in self.patches:
                _childs = [*_childs,*self.checks.children[p[0]:p[-1]+1]]
                _childs.append(HTML(''.center(25,'-')))
            self.views.children = _childs[:-1]
        else:
            self.views.children = self.checks.children

    @output.capture(clear_output=True,wait=True)
    def get_coords_labels(self):
        "`coords` are calculated for current `bz` even if `kpoints` were from other one. Useful in case of same kind of Zones with just basis changed."
        if self.bz:
            coords = [sio.to_R3(self.bz.basis,kp).tolist() if kp else [] for kp in self.kpoints]
        else:
            coords = self.coords.copy()
        labels = self.labels.copy()
        j = 0
        for p in self.patches[:-1]:
            labels.insert(p.stop+j,'NaN')
            coords.insert(p.stop+j,[np.nan,np.nan,np.nan])
            j += 1

        coords = np.array([c for c in coords if c])
        labels = [l for l in labels if l]
        return coords,labels

    @output.capture(clear_output=True,wait=True)
    def __update_selection(self):
        coords,labels = self.get_coords_labels()
        with self.fig.batch_animate():
            for trace in self.fig.data:
                if 'path' in trace.name and coords.any():
                    trace.x = coords[:,0]
                    trace.y = coords[:,1]
                    trace.z = coords[:,2]
                    trace.text = labels

    @output.capture(clear_output=True,wait=True)
    def __click(self):
        def handle_click(trace, points, state):
            if points.ys != []:
                index = points.point_inds[0]
                kp = trace.hovertext[index]
                kp = [float(k) for k in kp.split('[')[1].split(']')[0].split()]
                cp = [trace.x[index],trace.y[index],trace.z[index]]
                for i,c in enumerate(self.checks.children):
                    if c.value:
                        self.kpoints[i] = kp
                        self.coords[i] = cp
                        n,l = self.nkpts[i],self.labels[i]
                        c.description = "{0:>9.4f}{1:>9.4f}{2:>9.4f} -> {3}!{4}".format(*kp,n,l)
                        ind = (i+1) % len(self.kpoints) # Next Index
                        for i,c in enumerate(self.checks.children):
                            c.value = True if i == ind else False
                        break # Must break to avoid loop overflow

                self.__update_selection()

        for trace in self.fig.data:
            if 'HSK' in trace.name:
                trace.on_click(handle_click)

    @output.capture(clear_output=True,wait=True)
    def __update_fig(self,change=None):
        if self.files_dd.value:
            self.path = self.files_dd.value
            self.bz = sio.get_bz(self.path)
            fig_data = sio.iplot_bz(self.bz,fill=False,color='red',background='rgba(1,1,1,0)')
            self.fig.data = []
            with self.fig.batch_animate():
                self.fig.add_trace(go.Scatter3d(x = [],y = [],z = [],
                    mode='lines+text+markers',name='path',text=[],
                    textfont_size=18))
                self.__update_selection() #Show previous path on current fig.
                for trace in fig_data.data:
                    self.fig.add_trace(trace)

                self.fig.layout = fig_data.layout
                self.fig.layout.autosize=True
                self.fig.layout.scene.aspectmode = 'data' #very important

            self.__click()
        self.__toggle_theme(None) #Important to let text appear correctly


    @output.capture(clear_output=True,wait=True)
    def __label(self,change):
        for i,c in enumerate(self.checks.children):
            if c.value:
                inbox = self.texts['label'].value.split(',')
                self.labels[i] = inbox[0]
                try: self.nkpts[i] = int(inbox[1])
                except: pass
                kp,n,l = self.kpoints[i] ,self.nkpts[i],self.labels[i]
                if kp:
                    c.description = "{0:>9.4f}{1:>9.4f}{2:>9.4f} -> {3}!{4}".format(*kp,n,l)
                else:
                    c.description = "____  ____  ____ -> {0}!{1}".format(n,l)
                c.value = False
                ind = (i+1) % len(self.kpoints) # Next Index
                for i,c in enumerate(self.checks.children):
                    c.value = True if i == ind else False
                self.texts['label'].value = '' # Auto delete
                self.__update_selection()
                break # Must break to avoid loop overflow

    def get_kpath(self,n=5,weight=None,ibzkpt=None,outfile=None):
        "See Docs of pp.get_kpath for details."
        kws = dict(n=n,weight=weight,ibzkpt=ibzkpt,outfile=outfile)
        if self.patches:
            kps,ns = self.kpoints, self.nkpts
            hsk_list = [[[*kps[p],ns[p]] if ns[p]!='' else kps[p] for p in ps] for ps in self.patches]
            labels = self.labels.copy()
            for p1,p2 in zip(self.patches[:-1], self.patches[1:]): #Join before last patch
                labels[p1.stop - 1] = '{}|{}'.format(labels[p1.stop - 1],labels[p2.start])
                labels[p2.start] = ''
            labels = [l for l in labels if l!='']
        else:
            hsk_list = [[*kp,n] if n!='' else kp for kp,n in zip(self.kpoints,self.nkpts)]
            labels = self.labels
        return pp.get_kpath(hsk_list=hsk_list,labels=labels,**kws)

    def splot(self,**kwargs):
        "Same as `pp.splot_bz` except it also plots path on BZ. `kwargs` are passed to `pp.splot_bz`"
        ax = sio.splot_bz(path_pos_bz=self.path,**kwargs)
        coords,labels = self.get_coords_labels()
        plane = kwargs.get('plane',None)
        if plane != None and plane in 'xyzxzyx':
            ind = 'xyzxzyx'.index(plane)
            arr = [0,1,2,0,2,1,0]
            ix,iy = arr[ind],arr[ind+1]
            coords = coords[:,[ix,iy]]
        if coords.any(): #To avoid errors if not coords
            ax.plot(*coords.T,'-o',color='blue',lw=0.8)
            _ = [ax.text(*vs,lab) for vs,lab in zip(coords,labels) if lab!='NaN']
        return ax
    def iplot(self):
        "Returns disconnected current plotly figure"
        return go.Figure(data=self.fig.data, layout=self.fig.layout)
